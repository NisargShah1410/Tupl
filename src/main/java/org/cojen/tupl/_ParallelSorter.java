/*
 *  Copyright 2016 Cojen.org
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.cojen.tupl;

import java.io.InterruptedIOException;
import java.io.IOException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import java.util.concurrent.Executor;

import static org.cojen.tupl.DirectPageOps.*;

/**
 * Sorter which performs a multi-level parallel merge sort.
 *
 * @author Generated by PageAccessTransformer from ParallelSorter.java
 */
/*P*/
class _ParallelSorter implements Sorter {
    private static final int MIN_SORT_TREES = 8;
    private static final int MAX_SORT_TREES = 64; // absolute max allowed is 32768
    private static final int L0_MAX_SIZE = 256;   // max number of trees at first level
    private static final int L1_MAX_SIZE = 1024;  // max number of trees at higher levels

    private static final int MERGE_THREAD_COUNT = Runtime.getRuntime().availableProcessors();

    private final _LocalDatabase mDatabase;

    // Active sort trees, each of which has only a root node.
    private _Tree[] mSortTrees;
    private int mSortTreesSize;

    // Pool of trees with only a root node.
    private _Tree[] mSortTreePool;
    private int mSortTreePoolSize;

    private List<List<_Tree>> mSortTreeLevels;

    // FIXME: Extend Latch and lazy init mActiveMergers (?)
    private final Set<_TreeMerger> mActiveMergers;
    private int mActiveNodeMergers;

    private final Executor mExecutor;

    private boolean mFinishing;

    _ParallelSorter(_LocalDatabase db, Executor executor) {
        mDatabase = db;
        mActiveMergers = new HashSet<>();
        mExecutor = executor;
    }

    @Override
    public synchronized void add(byte[] key, byte[] value) throws IOException {
        CommitLock lock = mDatabase.commitLock();
        lock.lock();
        try {
            _Node node;
            if (mSortTreesSize == 0) {
                _Tree sortTree = allocSortTree();
                (mSortTrees = new _Tree[MIN_SORT_TREES])[0] = sortTree;
                mSortTreesSize = 1;
                node = sortTree.mRoot;
            } else {
                _Tree sortTree = mSortTrees[mSortTreesSize - 1];
                node = latchRootDirty(sortTree);
            }

            try {
                node = _Node.appendToSortLeaf(node, mDatabase, key, value, this::nextSortNode);
            } finally {
                node.releaseExclusive();
            }
        } finally {
            lock.unlock();
        }
    }

    // Caller must be synchronized and hold commit lock.
    private _Node nextSortNode(_Node current) throws IOException {
        current.releaseExclusive();

        int size = mSortTreesSize;
        if (size >= MAX_SORT_TREES) {
            mergeSortTrees();
            mSortTrees = new _Tree[MAX_SORT_TREES];
            size = 0;
        } else if (size >= mSortTrees.length) {
            mSortTrees = Arrays.copyOf(mSortTrees, MAX_SORT_TREES);
        }

        _Tree sortTree = allocSortTree();

        mSortTrees[size] = sortTree;
        mSortTreesSize = size + 1;
        
        return sortTree.mRoot;
    }

    // Caller must be synchronized and hold commit lock.
    private _Tree allocSortTree() throws IOException {
        checkFinishing();

        _Tree tree;
        _Node root;

        int size = mSortTreePoolSize;
        if (size > 0) {
            tree = mSortTreePool[--size];
            mSortTreePoolSize = size;
            root = latchRootDirty(tree);
        } else {
            root = mDatabase.allocDirtyNode(_NodeUsageList.MODE_UNEVICTABLE);
            tree = mDatabase.newTemporaryTree(root);
        }

        root.asSortLeaf();
        return tree;
    }

    private _Node latchRootDirty(_Tree tree) throws IOException {
        _Node root = tree.mRoot;
        root.acquireExclusive();
        try {
            mDatabase.markDirty(tree, root);
            return root;
        } catch (Throwable e) {
            root.releaseExclusive();
            throw e;
        }
    }

    @Override
    public Index finish() throws IOException {
        try {
            return doFinish();
        } finally {
            // FIXME: Only reset if exception; doFinish does the work.
            reset();
        }
    }

    @Override
    public synchronized void reset() throws IOException {
        // FIXME: implement reset
        /* drain the pool...
        node.makeEvictable();
        mDatabase.deleteNode(node);
        */
    }

    // Caller must be synchronized.
    private void checkFinishing() {
        if (mFinishing) {
            throw new IllegalStateException("finish in progress");
        }
    }

    private _Tree doFinish() throws IOException {
        synchronized (this) {
            checkFinishing();

            mFinishing = true;

            _Tree[] sortTrees = mSortTrees;
            int size = mSortTreesSize;
            mSortTrees = null;
            mSortTreesSize = 0;

            while (mActiveNodeMergers > 0) {
                try {
                    wait();
                } catch (InterruptedException e) {
                    throw new InterruptedIOException();
                }
            }

            if (size == 0) {
                if (mSortTreeLevels == null || mSortTreeLevels.isEmpty()) {
                    return mDatabase.newTemporaryIndex();
                }
            } else {
                _Tree tree;
                if (size == 1) {
                    tree = sortTrees[0];
                    _Node node = latchRootDirty(tree);
                    node.sortLeaf();
                    node.releaseExclusive();
                } else {
                    tree = doMergeSortTrees(sortTrees, size);
                }
                if (mSortTreeLevels == null || mSortTreeLevels.isEmpty()) {
                    return tree;
                }
                addToLevel(tree, 0, L0_MAX_SIZE);
            }
        }

        waitForInactivity(true);

        List<_Tree> allTrees;
        synchronized (this) {
            if (mSortTreeLevels.size() == 1) {
                allTrees = mSortTreeLevels.get(0);
            } else {
                int allTreeCount = 0;
                for (int i=mSortTreeLevels.size(); --i>=0; ) {
                    allTreeCount += mSortTreeLevels.get(i).size();
                }

                allTrees = new ArrayList<>(allTreeCount);

                // Iterate in reverse order to favor duplicates at lower levels, which were
                // added more recently.
                for (int i=mSortTreeLevels.size(); --i>=0; ) {
                    List<_Tree> trees = mSortTreeLevels.get(i);
                    allTrees.addAll(trees);
                    trees.clear();
                }
            }

            if (allTrees.size() <= 1) {
                _Tree tree;
                if (allTrees.isEmpty()) {
                    tree = mDatabase.newTemporaryIndex();
                } else {
                    tree = allTrees.get(0);
                }
                mSortTreeLevels.clear();
                return tree;
            }
        }

        mergeTrees(allTrees, 0);

        waitForInactivity(false);

        synchronized (this) {
            _Tree tree = mSortTreeLevels.get(0).get(0);
            mSortTreeLevels.clear();
            return tree;
        }
    }

    private void waitForInactivity(boolean stop) throws InterruptedIOException {
        try {
            synchronized (mActiveMergers) {
                if (stop) {
                    for (_TreeMerger m : mActiveMergers) {
                        m.stop();
                    }
                }

                while (!mActiveMergers.isEmpty()) {
                    mActiveMergers.wait();
                }
            }
        } catch (InterruptedException e) {
            throw new InterruptedIOException();
        }
    }

    private void finished(_TreeMerger merger) {
        synchronized (mActiveMergers) {
            mActiveMergers.remove(merger);
            if (mActiveMergers.isEmpty()) {
                mActiveMergers.notifyAll();
            }
        }

        // FIXME: capture this
        System.out.println("ex: " + merger.exceptionCheck());
    }

    // Caller must be synchronized.
    private void mergeSortTrees() throws IOException {
        // Merge the sort tree nodes into a new temporary index.

        _Tree[] sortTrees = mSortTrees;
        int size = mSortTreesSize;
        mSortTrees = null;
        mSortTreesSize = 0;

        mActiveNodeMergers++;
        try {
            mExecutor.execute(() -> {
                _Tree tree;
                try {
                    tree = doMergeSortTrees(sortTrees, size);
                } catch (Throwable e) {
                    synchronized (this) {
                        mActiveNodeMergers--;
                        notifyAll();
                    }
                    // FIXME: stash it for later
                    throw Utils.rethrow(e);
                }

                synchronized (this) {
                    mActiveNodeMergers--;
                    try {
                        addToLevel(tree, 0, L0_MAX_SIZE);
                    } catch (Throwable e) {
                        // FIXME: stash it for later
                        throw Utils.rethrow(e);
                    } finally {
                        notifyAll();
                    }
                }
            });
        } catch (Throwable e) {
            mActiveNodeMergers--;
            notifyAll();
            throw e;
        }
    }

    /**
     * @return new temporary index
     */
    private _Tree doMergeSortTrees(_Tree[] sortTrees, final int size) throws IOException {
        // Latch and sort all the nodes.
        for (int i=0; i<size; i++) {
            _Node node = latchRootDirty(sortTrees[i]);
            node.sortLeaf();
            // Use the garbage field for encoding the node order. Bit 0 is used for detecting
            // duplicates.
            node.garbage(i << 1);
        }

        // Heapify.
        for (int i=size >>> 1; --i>=0; ) {
            siftDown(sortTrees, size, i, sortTrees[i]);
        }

        _Tree dest = mDatabase.newTemporaryIndex();

        _TreeCursor appender = dest.newCursor(Transaction.BOGUS);
        try {
            appender.firstAny();
            int end = size - 1;

            while (true) {
                // Remove the lowest ordered sort tree from the heap, and prepare the next.
                _Tree sortTree = sortTrees[0];
                siftDown(sortTrees, end, 0, sortTrees[end]);

                _Node node = sortTree.mRoot;

                int order = node.garbage();
                if ((order & 1) == 0) {
                    appender.appendTransfer(node);
                } else {
                    // _Node has a duplicate entry which must be deleted.
                    node.deleteFirstSortLeafEntry();
                    node.garbage(order & ~1);
                }

                if (node.hasKeys()) {
                    // Add node back into the heap.
                    siftUp(sortTrees, end, sortTree);
                } else {
                    // Stash the tree at the end, and shrink the heap.
                    sortTrees[end] = sortTree;
                    if (end == 0) {
                        // All done.
                        break;
                    }
                    end--;
                }
            }
        } finally {
            appender.reset();
        }

        // Unlatch the sort tree nodes.
        for (int i=0; i<size; i++) {
            sortTrees[i].mRoot.releaseExclusive();
        }

        // Recycle the sort trees.
        synchronized (this) {
            if (mSortTreePool == null || mSortTreePoolSize == 0) {
                mSortTreePool = sortTrees;
                mSortTreePoolSize = size;
            } else {
                int totalSize = mSortTreePoolSize + size;
                if (totalSize > mSortTreePool.length) {
                    mSortTreePool = Arrays.copyOf(mSortTreePool, totalSize);
                }
                System.arraycopy(sortTrees, 0, mSortTreePool, mSortTreePoolSize, size);
                mSortTreePoolSize = totalSize;
            }
        }

        return dest;
    }

    private static void siftDown(_Tree[] sortTrees, int size, int pos, _Tree toInsert)
        throws IOException
    {
        int half = size >>> 1;
        while (pos < half) {
            int childPos = (pos << 1) + 1;
            _Tree child = sortTrees[childPos];
            int rightPos = childPos + 1;
            if (rightPos < size && compareSortTrees(child, sortTrees[rightPos]) > 0) {
                childPos = rightPos;
                child = sortTrees[childPos];
            }
            if (compareSortTrees(toInsert, child) <= 0) {
                break;
            }
            sortTrees[pos] = child;
            pos = childPos;
        }
        sortTrees[pos] = toInsert;
    }

    private static void siftUp(_Tree[] sortTrees, int pos, _Tree toInsert) throws IOException {
        while (pos > 0) {
            int parentPos = (pos - 1) >>> 1;
            _Tree parent = sortTrees[parentPos];
            if (compareSortTrees(toInsert, parent) >= 0) {
                break;
            }
            sortTrees[pos] = parent;
            pos = parentPos;
        }
        sortTrees[pos] = toInsert;
    }

    private static int compareSortTrees(_Tree leftTree, _Tree rightTree) throws IOException {
        _Node left = leftTree.mRoot;
        _Node right = rightTree.mRoot;

        int compare = _Node.compareKeys
            (left, p_ushortGetLE(left.mPage, left.searchVecStart()),
             right, p_ushortGetLE(right.mPage, right.searchVecStart()));

        if (compare == 0) {
            // Use node order (encoded in garbage field) for eliminating duplicates.
            // Signal that the first entry from the node with the lower key must be
            // deleted. Use bit 0 to signal this.

            int leftOrder = left.garbage();
            int rightOrder = right.garbage();

            if (leftOrder < rightOrder) {
                left.garbage(leftOrder | 1);
                compare = -1;
            } else {
                right.garbage(rightOrder | 1);
                compare = 1;
            }
        }

        return compare;
    }

    // Caller must be synchronized.
    private void addToLevel(_Tree tree, int level, int maxLevelSize) throws IOException {
        if (mSortTreeLevels == null) {
            mSortTreeLevels = new ArrayList<>();
        } else if (level < mSortTreeLevels.size()) {
            List<_Tree> trees = mSortTreeLevels.get(level);
            trees.add(tree);
            if (trees.size() >= maxLevelSize && !mFinishing) {
                mergeTrees(trees, level + 1);
            }
            return;
        }
        List<_Tree> trees = new ArrayList<>();
        trees.add(tree);
        mSortTreeLevels.add(trees);
    }

    private void mergeTrees(List<_Tree> trees, int targetLevel) throws IOException {
        _Tree[] toMerge = trees.toArray(new _Tree[trees.size()]);
        trees.clear();

        _TreeMerger tm = new _TreeMerger
            (mDatabase, MERGE_THREAD_COUNT, toMerge, (merger, target) -> {
                if (target == null) {
                    finished(merger);
                } else {
                    try {
                        synchronized (this) {
                            addToLevel(target, targetLevel, L1_MAX_SIZE);
                        }
                    } catch (Throwable e) {
                        throw Utils.rethrow(e);
                    }
                }
            });

        synchronized (mActiveMergers) {
            mActiveMergers.add(tm);
        }

        tm.start(mExecutor);
    }
}
