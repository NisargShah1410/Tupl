/*
 *  Copyright 2012-2015 Cojen.org
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.cojen.tupl;

import java.io.IOException;
import java.io.InterruptedIOException;

import java.util.concurrent.locks.LockSupport;

import org.cojen.tupl.ext.ReplicationManager;

import org.cojen.tupl.util.Latch;
import org.cojen.tupl.util.LatchCondition;

/**
 * 
 *
 * @author Generated by PageAccessTransformer from ReplRedoWriter.java
 */
/*P*/
class _ReplRedoWriter extends _RedoWriter {
    final _ReplRedoEngine mEngine;

    // Is non-null if writes are allowed.
    final ReplicationManager.Writer mReplWriter;

    // These fields capture the state of the last produced commit, but not yet confirmed.
    long mLastCommitPos;
    long mLastCommitTxnId;

    private volatile _PendingTxnWaiter mPendingWaiter;

    private final Latch mBufferLatch;
    private Thread mProducer;
    private Thread mConsumer;
    private byte[] mBuffer; // circular buffer; empty when tail < 0, full when head == tail
    private int mBufferHead;
    private int mBufferTail = -1;
    private long mWritePos; // absolute log position

    _ReplRedoWriter(_ReplRedoEngine engine, ReplicationManager.Writer writer) {
        mEngine = engine;
        mReplWriter = writer;

        if (writer == null) {
            mBufferLatch = null;
        } else {
            mBufferLatch = new Latch();
            mBufferLatch.acquireExclusive();
            mWritePos = writer.position();
            mBuffer = new byte[65536];
            mBufferLatch.releaseExclusive();

            Thread consumer = new Thread(() -> {
                consume();
            });

            consumer.setName("WriteConsumer-" + consumer.getId());
            consumer.setDaemon(true);
            consumer.start();
        }
    }

    @Override
    public final void txnCommitSync(_LocalTransaction txn, long commitPos) throws IOException {
        ReplicationManager.Writer writer = mReplWriter;
        if (writer == null) {
            throw mEngine.unmodifiable();
        }
        if (writer.confirm(commitPos)) {
            txn.mContext.confirmed(commitPos, txn.txnId());
        } else {
            throw nowUnmodifiable();
        }
    }

    @Override
    public final void txnCommitPending(_PendingTxn pending) throws IOException {
        _PendingTxnWaiter waiter = mPendingWaiter;
        int action;
        if (waiter == null || (action = waiter.add(pending)) == _PendingTxnWaiter.EXITED) {
            acquireExclusive();
            try {
                waiter = mPendingWaiter;
                if (waiter == null || (action = waiter.add(pending)) == _PendingTxnWaiter.EXITED) {
                    waiter = new _PendingTxnWaiter(this);
                    mPendingWaiter = waiter;
                    action = waiter.add(pending);
                    if (action == _PendingTxnWaiter.PENDING) {
                        waiter.setName("_PendingTxnWaiter-" + waiter.getId());
                        waiter.setDaemon(true);
                        waiter.start();
                    }
                }
            } finally {
                releaseExclusive();
            }
        }

        if (action != _PendingTxnWaiter.PENDING) {
            _LocalDatabase db = mEngine.mDatabase;
            if (action == _PendingTxnWaiter.DO_COMMIT) {
                pending.commit(db);
            } else if (action == _PendingTxnWaiter.DO_ROLLBACK) {
                pending.rollback(db);
            }
        }
    }

    protected final void flipped(long commitPos) {
        _PendingTxnWaiter waiter;
        acquireExclusive();
        try {
            waiter = mPendingWaiter;
            if (waiter == null) {
                waiter = new _PendingTxnWaiter(this);
                mPendingWaiter = waiter;
                // Don't start it.
            }
            waiter.flipped(commitPos);
        } finally {
            releaseExclusive();
        }

        waiter.finishAll();
    }

    /**
     * Block waiting for the given committed position to be confirmed. Returns false if not the
     * leader.
     */
    final boolean confirm(_PendingTxn pending) {
        // Note: Similar to txnCommitSync.

        ReplicationManager.Writer writer = mReplWriter;
        if (writer == null) {
            return false;
        }

        long commitPos = pending.mCommitPos;

        try {
            if (writer.confirm(commitPos)) {
                pending.mContext.confirmed(commitPos, pending.mTxnId);
                return true;
            }
        } catch (IOException e) {
            // Treat as leader switch.
        }

        mEngine.mController.switchToReplica(mReplWriter, false);

        return false;
    }

    @Override
    public final long encoding() {
        return mEngine.mManager.encoding();
    }

    @Override
    public _RedoWriter txnRedoWriter() {
        return this;
    }

    @Override
    boolean shouldCheckpoint(long sizeThreshold) {
        return false;
    }

    @Override
    void checkpointPrepare() throws IOException {
        throw fail();
    }

    @Override
    void checkpointSwitch(_TransactionContext[] contexts) throws IOException {
        throw fail();
    }

    @Override
    long checkpointNumber() {
        throw fail();
    }

    @Override
    long checkpointPosition() {
        throw fail();
    }

    @Override
    long checkpointTransactionId() {
        throw fail();
    }

    @Override
    void checkpointAborted() {
    }

    @Override
    void checkpointStarted() throws IOException {
        throw fail();
    }

    @Override
    void checkpointFlushed() throws IOException {
        throw fail();
    }

    @Override
    void checkpointFinished() throws IOException {
        throw fail();
    }

    @Override
    DurabilityMode opWriteCheck(DurabilityMode mode) throws IOException {
        // All redo methods which accept a DurabilityMode must always use SYNC mode. This
        // ensures that write commit option is true, for capturing the log position. If
        // Transaction.commit sees that DurabilityMode wasn't actually SYNC, it prepares a
        // _PendingTxn instead of immediately calling txnCommitSync. Replication makes no
        // distinction between NO_FLUSH and NO_SYNC mode.
        return DurabilityMode.SYNC;
    }

    @Override
    boolean shouldWriteTerminators() {
        return false;
    }

    @Override
    final long write(boolean commit, byte[] bytes, int offset, int length) throws IOException {
        if (mReplWriter == null) {
            throw mEngine.unmodifiable();
        }

        long pos;

        mBufferLatch.acquireExclusive();
        try {
            byte[] buffer = mBuffer;
            if (buffer == null) {
                throw nowUnmodifiable();
            }

            while (true) {
                if (mBufferHead == mBufferTail) {
                    mProducer = Thread.currentThread();
                    try {
                        do {
                            mBufferLatch.releaseExclusive();
                            LockSupport.unpark(mConsumer);
                            LockSupport.park();
                            mBufferLatch.acquireExclusive();
                            buffer = mBuffer;
                            if (buffer == null) {
                                throw nowUnmodifiable();
                            }
                        } while (mBufferHead == mBufferTail);
                    } finally {
                        mProducer = null;
                    }
                }

                int amt;
                if (mBufferHead < mBufferTail) {
                    amt = buffer.length - mBufferTail;
                } else if (mBufferTail >= 0) {
                    amt = mBufferHead - mBufferTail;
                } else {
                    mBufferHead = 0;
                    mBufferTail = 0;
                    amt = buffer.length;
                }

                if (length <= amt) {
                    System.arraycopy(bytes, offset, buffer, mBufferTail, length);

                    pos = mWritePos += length;
                    if ((mBufferTail += length) >= buffer.length) {
                        mBufferTail = 0;
                    }

                    if (commit) {
                        mLastCommitPos = mWritePos;
                        mLastCommitTxnId = mLastTxnId;
                    }

                    break;
                }

                System.arraycopy(bytes, offset, buffer, mBufferTail, amt);

                mWritePos += amt;
                length -= amt;
                offset += amt;

                if ((mBufferTail += amt) >= buffer.length) {
                    mBufferTail = 0;
                }
            }

            LockSupport.unpark(mConsumer);
        } finally {
            mBufferLatch.releaseExclusive();
        }

        return pos;
    }

    @Override
    void alwaysFlush(boolean enable) throws IOException {
        // Always flushes already.
    }

    @Override
    void force(boolean metadata) throws IOException {
        mEngine.mManager.sync();
    }

    @Override
    public void close() throws IOException {
        mEngine.mManager.close();
    }

    private UnsupportedOperationException fail() {
        // _ReplRedoController subclass supports checkpoint operations.
        return new UnsupportedOperationException();
    }

    private UnmodifiableReplicaException nowUnmodifiable() throws DatabaseException {
        return mEngine.mController.nowUnmodifiable(mReplWriter);
    }

    /**
     * Consumes data from the circular buffer and writes into the replication log. Method doesn't
     * exit until leadership is revoked.
     */
    private void consume() {
        mBufferLatch.acquireExclusive();
        mConsumer = Thread.currentThread();

        while (true) {
            byte[] buffer = mBuffer;
            int head = mBufferHead;
            int tail = mBufferTail;
            long commitPos = mLastCommitPos;

            try {
                if (head == tail) {
                    // Buffer is full, so consume everything with the latch held.

                    // Write the head section.
                    if (mReplWriter.write(buffer, head, buffer.length - head, commitPos) < 0) {
                        break;
                    }

                    if (head > 0) {
                        // Write the tail section.
                        mBufferHead = 0;
                        if (mReplWriter.write(buffer, 0, tail, commitPos) < 0) {
                            break;
                        }
                    }

                    // Buffer is now empty.
                    mBufferTail = -1;
                } else if (tail >= 0) {
                    // Buffer is partially full. Consume it with the latch released, to
                    // allow a producer to fill in a bit more.
                    mBufferLatch.releaseExclusive();
                    try {
                        if (head < tail) {
                            // No circular wraparound.
                            if (mReplWriter.write(buffer, head, tail - head, commitPos) < 0) {
                                break;
                            }
                            head = tail;
                        } else {
                            // Write only the head section.
                            int len = buffer.length - head;
                            if (mReplWriter.write(buffer, head, len, commitPos) < 0) {
                                break;
                            }
                            head = 0;
                        }
                    } finally {
                        mBufferLatch.acquireExclusive();
                    }

                    if (head != mBufferTail) {
                        // More data to consume.
                        mBufferHead = head;
                        continue;
                    }

                    // Buffer is now empty.
                    mBufferTail = -1;
                }
            } catch (Throwable e) {
                if (!(e instanceof IOException)) {
                    Utils.uncaught(e);
                }
                // Keep consuming until an official leadership change is observed.
                Thread.yield();
                continue;
            }

            // Wait for producer and loop back.
            mBufferLatch.releaseExclusive();
            LockSupport.unpark(mProducer);
            LockSupport.park(mBufferLatch);
            mBufferLatch.acquireExclusive();
        }

        mConsumer = null;
        mBuffer = null;
        LockSupport.unpark(mProducer);
        mBufferLatch.releaseExclusive();

        mEngine.mController.switchToReplica(mReplWriter, false);
    }
}
